中序遍历的规则是：左子树---> 根结点 ---> 右子树。所以我们访问节点的顺序需要变。

* 我们直到递归是来回的过程，对于恰好有两个子节点(子节点无节点)的节点来说。只需要访问一次左节点，访问根，访问右节点。即可。
* 而如果两侧有节点来说。每个节点都要满足中序遍历的规则。我们从根先访问左节点。到了左节点这儿左节点又变成一颗子树，也要满足中序遍历要求。所以就要先访问左节点的左节点(如果存在)。那么如果你这样想，规则虽然懂了。但是也太复杂了。那么我们借助递归。因为它的子问题和根节点的问题一致，只是范围减小了。所以我们使用递归思想来解决。
* 那么递归的逻辑为：考虑特殊情况(特殊就直接访问)不进行递归否则递归的访问左子树(让左子树执行相同函数，特殊就停止递归输出，不特殊就一直找下去直到最左侧节点。)——>输出该节点—>递归的访问右子树.

### 递归 中序遍历

```js
function dfs (root) {
    if (root !== null) {
        dfs(root.left);
        console.log(root.val);
        dfs(root.right);
    }
}
```

### 非递归中序遍历

非递归中序和前序有所区别。

我们直到中序排列的顺序是：左节点，根节点，右节点。那么我们在经过根节点的前面节点 不能释放， 因为后面还需要用到它。所以要用栈先储存。

* 栈依次存入左节点所有点，直到最左侧在栈顶。 
* 开始抛出栈顶并访问。(例如第一个抛出2)。
* 如果有右节点。那么将右节点加入栈中，然后右节点一致左下遍历直到尾部。
* （这里5和7没有左节点，所以不加）但是如果抛出15。
* 右节点加入23.再找23的左侧节点加入栈顶。就这样循环下去直到栈为空。

```js
function dfs (root) {
    let queue = [];
    if (queue.length || root !== null) {
        if (root != null) {
            queue.push(root);
            root = root.left;
        } else {
            root = queue.pop();
            console.log(root.val);
            root = root.right;
        }
    }
}
```

